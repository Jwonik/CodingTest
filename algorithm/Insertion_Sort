package algorithm;
// [알고리즘] - 삽입 정렬
// 삽입 정렬: 현재 비교하고자 하는 원소솨 그 이전의 원소들을 비교하며 교환하는 방식
// 
// 1) 정렬 방법
// (1) 현태 타겟이 되는 숫자와 이전 위치에 있는 원소들은 비교한다. (첫 번째 타겟은 두 번쨰 원소부터 시작한다.)
// (2) 타겟이 되는 숫자가 이전 위치에 있는 원소보다 적다면 위취를 서로 교환한다.
// (3) 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.

// 2) 장점
// (1) 추가적인 메모리 소비가 적다.
// (2) 거의 정렬된 경우 매우 효율적이다.
//     즉, 최선의 경우 O(N)의 시간 복잡도를 가진다.
// (3) 안정 정렬이 가능하다.

// 3) 단점
// (1) 역순에 가까울수록 매우 비효율적이다.
//     즉, 최악의 경우 O(N^2)의 시간복잡도를 가진다.
// (2) 데이터의 상태에 따라서 성능 편차가 매우 크다.

// 4) 코드 구현
public class Insertion_Sort {
	public static void insertion_sort(int[] a) {
		insertion_sort(a, a.length);
	}
	
	private static void insertion_sort(int[] a, int size) {
		
		for(int i = 1; i < size-1; i++) {
			// 타겟 넘버
			int target = a[i];
			
			int j = i - 1;
			
			// 타겟이 이전 원소보다 크기 전까지 반복
			while(j >= 0 && target < a[j]) {
				a[j+1] = a[j];
				j--;
			}
			
			/* 
			 * 위 반복문에서 탈출하는 경우, 앞의 원소가 타겟보다 작다는 의미이므로  
			 * 타겟 원소는 j번째 원소 뒤에 와야한다.
			 * 그러므로 타겟은 j+1 에 위치하게 된다.
			 */
			a[j+1] = target;
		}
		
	}
}
